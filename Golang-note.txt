package main	
	//package 声明文件属于哪个包  main函数必须放在main包  编译生成可执行文件 
	
import (      //引入包时用文件夹的路径   一个文件夹只能有一个包 
	"Aaa/qqq" 
	_ "fmt"   // _ 忽略这个包 
)  
	函数外只能放标识符(变量 常量 函数 类型)的声明，必须以"关键字"开头  
		 
func main(){  	 //入口函数  
## 声明变量  
	初始值为空  非全局变量声明之后必须使用  严格区分大小写 
	var A int       
	var s1="hello"    //类型推导
	var s2 int = 1
	var s3 = int8(2)  //强制转换
	s4:=12    	      //省略var关键字  只能在函数内使用 
	s5:=int8(2)
	
	//批量声明
	var(
		A string
		B int
		C bool
	)  
	var a,b,c =0,1,2 	
//变量作用域 
	全局变量可以在整个包中使用，首字母大写可以在整个程序中使用（包名.变量名）
	局部变量只在本函数内生效 
	//语句块中的作用域 
	if判断、for循环、switch 等语句中定义的变量只在本语句中生效 
	若变量名相同，编译器会采用就近原则，优先使用小范围内的变量
//变量名格式    
	推荐使用小驼峰
	var studentName string //小驼峰 
	var StudentName string //大驼峰 
	var student_name string//下划线 
//定义常量  
	定义之后不能修改 不会改变 
	const pi=3.1415926
	const (
		s1=100
		s2    //默认和上一行值一样 
		s3
	) 
    //iota      计数器
	const(
		b1=iota  //iota在const出现时被置为0 每新增一行常量声明就加一
		b2       //1
		_        //2
		b3       //3
	) 
	//定义数量级
	const(
		_ =iota        //iota=0
		KB=1<<(10*iota)//iota=1 二进制1左移10*1位 2^10 10000000000 1024 B 
		MB=1<<(10*iota)//iota=2 二进制1左移10*2位 2^20   1024*1024 
		GB=1<<(10*iota)
		TB=1<<(10*iota)
	) 
## 输入与输出 
	//输出语句 
	fmt.Print(A) 直接输出要打印的内容 
	fmt.Printf("name:%s\n",A)  %s:占位符 字符串类型  \n:换行符 
    fmt.Println(a) 末尾输出一个换行符 
	//输入语句 
	fmt.Scan(&a,&b)  //键盘输入时以空格作为分隔符  
	fmt.Scanf("%d",&a) 
	fmt.Scanln(&a)  
	//格式化 
	s=fmt.Sprint (A,"你好") //返回格式化后的字符串 
	s=fmt.Sprintf("A=%d",A)
## 基本数据类型
	//值类型：    通常存放在栈区中
	int  float  bool  string  数组  结构体    
	//引用类型：  通常存放在堆区中  没有变量引用存放的地址时由GC回收 
	指针  slice切片  map  chan管道  interface接口   
	引用类型默认值为nil 
//占位符:
	fmt.Printf("%T\n",A)//用 unsafe.Sizeof() 可以返回变量占用的字节数	 
	%T 变量的类型 
	%v 默认类型值（万能）%#v 标注变量的类型
	%b 二进制  %d十进制  %o八进制  %x十六进制 
	%f 浮点数  %9.2f  
	%c 字符 （数对应的unicode码的符号） 
	%s 字符串
	%q 带引号的字符/字符串的值，必要时采用安全的转义表示
	%p 内存地址（指针）  & ：取(变量)地址 
	%t 布尔值 
	%U Unicode格式:U+1234 等价于 U+%04X 
	%% 百分号
	//字符串转义符 
	\	\r 回车符 \n 换行符 \t 制表符（Tab键） \"" 双引号 \\ 反斜杠 

//自定义类型与类型别名
	定义之后go认为是新的数据类型，不可直接相互赋值，需要强转 
	type a int	//自定义类型  打印类型：main.a  这里认为a和int不是一个类型   但是如果是自定义的函数类型，则认为是同一个类型 
	type b=int  //类型别名 	  打印类型：int     如byte是uint8的类型别名 而rune是int32 
	
//整形      
	int //带符号整型    根据操作系统位数定值int32或int64
		int8     
		int16	//一位是符号位  范围：（ -2^15到2^15-1）
		int32   //rune 
		int64
	uint//无符号整型 
		uint8    //（0到255）
		uint16
		uintptr  //存放指针 
	//超出值范围溢出 
	a:=int8(3) 
	a+=127 //可以编译通过，但是会发生溢出，结果为-126 
		计算机运行使用"补码"计算,手动模拟计算方式：先取反码再取补码，然后相加，再转换回反码然后转换回源码 
	a+=128 //不可以编译通过，128本身已经超过int8的范围
	 
	//八进制和十六进制  
	A:=999         //十进制 
	A:=0777        //八进制 
	A:=0x19abcdef  //十六进制  
	fmt.Printf(" %d %b %o %x ",A)//%d 十进制 %b 二进制 %o 八进制 %x 十六进制   
//浮点型小数 
	float32	 float64    //两个完全不同的类型值  不能直接相互赋值 
	math.MaxFloat32	  math.MaxFloat64  //最大值
	f1:=1.23456 // 默认为float64 
	f2:=float32(1.23456) 
	fmt.Printf("%T\n", f2) //32位 
	求平均值的时候需要将int类型的强转到float 
//复数
	var a1 complex64       var a2 complex128
	a1=1+2i
	fmt.Println(a1)
//布尔值            1            0
	bool  只有true（真）和false（假）两个值 
	默认值为false     
	不允许将整形（0 1）强制转换为布尔型 
	无法参与数值运算，也无法与其他类型进行转换 
//字符串   
	%s 类型：string     底层是byte数组 
	%c 类型：字符 byte（uint8）表示 ASCII码字符（0~127） 
			    //rune（int32）代表 UTF-8  字符(可放汉字(3个字节),UTF-8是可变长编码，兼容ASCII码)  
	字符串中的转义字符会被识别，\n输出时会换行  \t输出制表符 
	//多行字符串  
	A:= `
		田某某    //` ` 反引号中的内容会原样输出 
		大帅B
	`
    //字符串相关操作：
	B:="理想"
	C:="大帅B" 
	len(B)  //字符串长度
	D:=B+C  //字符串拼接，若需要分行写就需把加号留在上一行 
	D:=fmt.Sprintf(B,C) //字符串拼接，不打印，同上 
    //修改字符串：
	s2:=[]rune(s1)  //切割字符串为[]rune或[]byte类型的切片，有汉字时用rune  
	    （修改其中一些字符） 
	s1=string(s2)  //再转换成字符串类型
	//字符串切割
	s:="how do you do"		//按空格切割  s3为切片类型 
	s3:=strings.Split(s," ") 
	//字符串中的子串   （以下字符串位置均可使用变量） 
	b:=strings.Contains("seafood","foo") //true 判断是否含有某子串 
	n:=strings.Count("seafood","o")      //2    返回子串的个数 
	index:=strings.Index("NLT_abc","abc")//4    子串第一次出现时的下标 
	index:=strings.Index("go go12","abc")//
